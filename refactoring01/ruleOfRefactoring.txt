-리팩토링 정의

리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 위해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
        ex) 함수 추출하기, 조건부 로직을 다형성으로 바꾸기

리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

코드를 잘게 나눔으로써 처음에는 오래 걸릴 수 있지만, 후에 디버깅을 하는데 있어서 시간을 뺏기지 않을 수 있다.

그리고 리팩터링은 전과 후의 코드 동작이 같아야 한다.

리팩터링은 성능 최적화와 비슷하다. 코드 전반적인 기능은 차이가 거의 없을 정도로 유지함.
리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 수정하는 데에 있다.

성능 최적화는 오로지 속도 개선에만 신경을 쓰기 때문에 속도 성능을 위해서는 코드 다루기가 더 어려워 질 수도 있다.

-두 개의 모자

소프트웨어를 개발 할 때는 두 가지 목적으로 나뉘어진다. 기능 추가인가 혹은 리팩터링을 위해서 인가 이다.

기능추가를 위해서는 기존 코드를 절대 건드리지 않고 오로지 새 기능을 추가하는 것에만 집중한다.

하지만 리팩터링을 위해서는 기능을 추가하지 않고 오로지 코드 재구성에만 전념한다.

테스트도 예외의 상황(앞 과정에서 놓친 테스트 케이스를 발견하는 경우)을 제외하고 새로 만들지 않는다.

부득이하게 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.


- 리팩터링을하는 이유

1. 리팩터링하면 소프트웨어 설계가 좋아진다.

아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너진다. 즉, 코드를 통해 설계를 알 수 없게 되고 후에 유지보수면에서도
큰 어려움을 겪게 된다. 규칙적인 리팩토링은 코드의 구조를 지탱해준다.

물론 코드량이 준다고 해서 속도에 큰 영향을 미치는 것은 아니다. 하지만 코드량이 줄면 수정하는데에 드는 노력이 줄어 들이는 시간이 줄어든다.

2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

프로그래밍은 마치 컴퓨터와 대화하는 것과 같다. 그래서 내가 작성한 코드와 컴퓨터에서 시키려는 일의 차이를 줄여야 한다.
또한 몇 달이 지나 누군가 내 코드를 수정하는 것을 고려한다면, 내 소스는 컴퓨터만이 사용하는 것이 아니다.
컴파일이 조금 더 걸린다고 해서 큰 문제가 되지는 않지만, 내 코드를 수정하느라 하루이틀, 일주일 이상이 걸리게 된다면 사정이 달라지게 된다.

리팩터링은 코드가 더 잘 읽히게 도와준다. 그러므로 코드의 목적을 잘 드러내기 위해, 다시 말해 내 의도를 잘 표현하기 위해 개선해야 한다.

단적인 예로 내가 작성한 코드를 며칠 뒤에만 봐도 이해되지 않는다. 그러므로 나를 위해서라도 이해하기 쉽게 코드를 작성하는 것이 좋다.

3. 리팩터링하면 버그를 쉽게 찾을 수 있다.

4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.

리팩터링 하는데 시간이 드니 전체 개발 속도에 영향이 미칠 수 있다는 생각이 들 수 있다. 물론 초기에는 많은 시간이 걸릴 수 있겠지만,
리팩터링이 잘 된 코드는 기존에 작성한 코드를 최대한 활용할 수 있기 때문에 더 빨리 기능을 추가할 수 있게 된다.

시간 차이의 원인은 소프트웨어의 내부 품질 차이이다. 모듈화가 잘 되어있다면 전체 코드베이스 중 일부만을 수정하면 되기 때문에 어디에 추가할지 고칠지를 알 수 있다.

빠른 개발을 위해서는 이처럼 리팩터링이 반드시 필요하다.


- 언제 리팩터링해야 할까?

3의 법칙
1. 처음에는 그냥한다
2. 비슷한 일을 두 번째로 하게 되면(중복이 생김), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게되면 리팩터링 해야한다.

*준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
함수 매개변수화하기를 적용하여 함수에 필요한 매개변수를 지정해서 호출하기만 하면 됨.
버그를 잡을 때에도 우선 한 곳에 합친 후 작업이 꼬이는 경우를 줄일 수 있다.

*이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
코드를 수정하려면 일단 그 코드가 하는 일을 파악하여야 하는데 내가 파악할 수도, 타인이 파악할 수도 있다.
리팩터링을 하면 머리로 이해한 것을 코드에 옮길 수 있고, 수정한 코드를 테스트하며 확인할 수 있다.

이런 리팩토링은 당장 효과를 볼 때도 많다.

*쓰레기 줍기 리팩터링
코드를 리뷰하며 로직이 쓸데 없이 복잡하거나, 거의 똑같은 함수를 여러개로 작성한 경우를 발견할 수 있다.
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 주석 또는 메모를 남기고 하던 일을 마친 후에 수정하는 것도 좋은 방법이다.
코드를 조금 씩 수정하다보면 결국 문제가 해결되는 경우도 있을 것이다.

*계획된 리팩터링과 수시로 하는 리팩터링
리팩터링은 눈 앞의 문제에도 유용하지만 장기적인 작업에도 도움을 준다.
'보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.'

그러므로 리팩터링 작업은 대부분 드러나지 않게 기회가 될 때마다 해야한다.

*오래걸리는 리팩터링
리팩터링은 대부분 몇 분 안에 끝나지만, 오래 걸리는 경우도 있다. 이럴 때는 한 번에 해결하려고 하는 것보다는 몇 주에 걸쳐 조금씩
해결해가는 편이 효과적일 때가 많다.
기존 코드가 추상 인터페이스를 호출하돋록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다(추상화로 갈아타기)

*코드 리뷰에 리팩터링 활용하기
내 눈에는 명확히 보이는 코드도 다른 이의 눈에는 그렇지 않을 수도 있다. 그러므로 코드 리뷰를 할 수 있다면 개발팀 전체에 코드를 공유하여 피드백을 받는 것이 좋다.
리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 된다. 다른 이의 코드를 리뷰하면서 개선안들을 제시하고, 그 중 상당수를 즉시 구현하여
성취감을 맛볼 수도 있다.

*관리자에게는 뭐라고 말해야 할까?
기술을 모르는 상당수에 관리자는 리팩터링을 하지 말라고 한다. 리팩터링의 영향을 잘 모르기 때문이다. 그럴 때는 '리팩터링한다고 말하지 말라' 를 권한다.
물론 일정을 최우선으로 하는 관리자는 빨리 개발이 끝나길 원하지만 개발자들의 임무는 새로운 기능을 빠르고, 재사용하기 쉽게 구현하는 것이다.
그래서 리팩터링은 해야한다.

*리팩터링하지 말아야 할 때
지금까지는 리팩토링을 무조건 권장하는 것처럼 들렸는데, API 를 호출하는 등 굳이 수정할 필요가 없는 코드라면 지저분해도 수정하지 않는다.
리팩터링하는 것보다 처음부터 작성하는 게 쉬울 때도 리팩터링 하지 않는다.

-리팩터링 시 고려할 문제

*새 기능 개발 속도 저하
리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것 이다.

즉 리팩터링에 있어서는 상황에 맞게 조율하는 것이 필요하다.

코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.

*코드 수요권
한 함수나 코드에 대해서는 한 사람이 관리하는 것이 리팩터링 면에서도 좋고, 소유권을 나눈다면 인터페이스를 수정하는 경우 모두가 확인하거나 꼬이는 경우가
생길 수 있어서 조심해야 한다.

팀 코드에 브랜치를 따서 수정하고 커밋을 요청하는 방식을 지양한다. 코드 소유권을 엄격하게 제한하는 방식과 완전히 푸는 방법의 절충안이라고 할 수 있다.

*브랜치
각 개발자가 독자적인 브랜치에 개발하고 마스터 브랜치에 한 번에 통합하는 방법이 버전을 명확히 나눌 수 있고, 기능에 문제가 생기는 경우 이전 상태로 쉽게
돌릴 수 있어서 좋다고 한다.

하지만 독자적인 개발 시간이 길어질 수록 작업 결과를 통합하기 어려워진다. 그래서 마스터를 개인브랜치로 수시로 리베이스하거나 머지한다.

CI(지속적통합)는 머지의 복잡도를 낮출 수는 있지만, 마스터를 건강하게 유지하기 위해 노력해야하고, 거대한 기능을 잘게 쪼개며, 각 기능을 끌 수 있는 기능 토글을
적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

*테스팅
리팩터링에서 핵심은 오류를 재빨리 잡는데에 있다. 실제로 이렇게 하기 위해서는 코드의 다양한 측면을 검사하는 테스트 스위트가 필요하다.

자가 테스트 코드는 효과가 상당한데, 새 기능 추가도 훨씬 안정하게 진행할 수 있게 도와준다.
실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다.

또한 리팩터링 과정에서 버그가 생길 위험이 크다는 불안감도 해소할 수 있다.

-리팩터링, 아키텍처, 애그니

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.
우리는 요구사항 파악을 잘하지 못한다. 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.

한 가지 방법은 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다.

함수를 범용적으로 사용할 수도 있다는 생각이 들 때가 있는데, 그 시나이로에 대응하기 위해서 매개변수들을 추가한다.
이런 매개변수가 유연성 메커니즘이다.

물론 유용한 수단이지만 계속 사용하다보면 당장의 쓰임에 비해 함수가 너무 복잡해진다.
또한 깜박 잊은 경우, 추가된 매개변수로 인해서 다시 추가하기가 어려워지는 경우가 있다. 이러한 연유로 유연성 매커니즘을 잘못 구현할 때도 있다.

이러한 문제를 리팩토링을 이용해서 해결할 수 있다.
앞으로 어느 부분에 유연하게 대처할 것이고 변화에 대응할 것인지를 추측하고 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.
그리고 이 요구를 만족하기 위한 설계를 한다.

리팩토링을 진행하면서 사용자의 요구사항을 더 잘이해하게 되면 아키텍처도 그에 맞게 리팩터링하여 바꾼다.
이 때 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.
매개변수를 추가할 시점이 오면 간단한 리팩터링 기법인 함수 매개변수화하기로 해결한다.

이런식의 설계 방식을 간결한 설계, 점진적 설계, YAGNI(you aren't going to need it)이라고 불린다.
이 때 아키텍처를 전혀 고려하지 말라는 뜻은 아니다. YAGNI 또한 리팩토링의 뒷받침 없이는 효과를 볼 수 없다.


-리팩터링과 소프트웨어 개발 프로세스

XP 가 도입되면서 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶기 시작했다.
이것을 TDD (테스트 주도 개발) 이라고 한다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다. 프로그래밍 중 일어나는 오류를 확실하게 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.

따라서 YAGNI는 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법으로 강력한 상승효과를 만들어 낼 수 있다.


아무것도 안 만드는 데도 시간이 걸린다. _론 제프리
시스템에 대해서 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다.
그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

리팩터링은 성능 좋은 소프트웨어를 만드는데 기여한다.
단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에
결국 더 빠른 소프트웨어를 얻게 된다.

-코드가 풍기는 악취

*기이한 이름
함수의 이름을 명확하게 쓰는 것도 중요하다. 리팩터링에서 가장 어려운 것 중 하나가 함수, 변수 이름 짓기 이다.
이를 이용한 방법이 한수 선언 ㅂ바꾸기, 변수 이름 바구기, 필드 이름 바꾸기 이다.

따라서 이름만 잘 지어도 나중에 문맥을 파악하느라 해매는 시간을 줄이게 된다.

*중복 코드
똑같은 코드 구조가 반복된다면 하나로 통합하여 좋은 프로그래밍 프로세스를 만들 수 있다.
한 클래스에 비슷한 메서드가 있다면 함수 추출하기를 이용하여 추출하면 되고,
코드가 비슷하긴 한데 완전히 똑같지는 않다면, 먼저 문장 슬라이드하기로 비슷한 부분을 모아 함수 추출하기를 더 용이하게 할 수 있을 것이다.
같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 메서드 올리기를 적용하여 부모로 옮긴다.

*긴 함수
나의 경험상으로도 코드는 짧게 작성하는 편이다. 하지만 이런 코드들은 프로세스를 파악하기 위해 왔다 갔다 해야하므로 부담이 크다.
짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.

함수의 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다. 또한 함수의 이름에 목적이 드러나게 지어야 한다.
함수를 짧게 만드는 작어브이 99%는 함수 추출하기 이다.

ex) switch 문에서 case가 너무 방대하다면 함수 추출하기를 통해 각 case에 있는 로직을 함수로 만들어 구분하는 것도 하나의 방법이다.

*긴 매개변수 목록
전역 데이터를 줄이는 것은 당연한 것이지만, 그렇다고 매개변수를 너무 방대하게 늘려서도 안된다.
이는 매개변수를 질의 함수로 바꾸기로 제거할 수 있다.

사용 중인 데이터 구조에서 값들을 뽑아 각각 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기를 이용하여 데이터 구조를 그대로 전달한다.
항상 함께 전달되는 매개변수들은 매개변수 객체 만들기로 하나로 묶어버린다.
함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애준다.

*전역 데이터
전역 데이터의 남용을 막기위해서 사용하는 리팩터링은 변수 캡슐화하기 이다. 이를 통해서 전역 데이터가 손상되거나 변경되는 것을 방지할 수 있다.
더 나아가 접근자 함수들을 클래스나 모듈에 넣고 그 안에서만 사용하도록 하는 것이 제일 좋은 방법이다.

*가변 데이터
변수의 유효범위가 단 몇 줄 뿐이라면 가변 데이터라 하더라도 문제를 일으킬 위험은 없지만, 나중에라도 범위가 넓어진다면 위험도도 같이 커지게 된다.
따라서 여러 함수를 클래스로 묶거나, 여러 함수를 변환 함수로 묶는 방법을 이용하여 코드의 유효범위를 제한한다.

*뒤엉킨 변경

*산탄총 수술
코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때를 말한다.
이럴 때는 변경되는 대상들을 함수 옮기기와 필드 옮기기로 한 모듈에 묶는 것이 좋다.

비슷한 데이터를 다루는 함수가 많은 경우 여러 함수를 클래스로 묶기도 좋은 방법이다.
데이터 구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환 함수로 묶기를 적용한다.

이렇게 묶은 함수들은 다음 단계 로직 전달을 위해 단계 쪼개기를 적용한다.

*기능 편애

*데이터 뭉치
데이터 뭉치는 항상 함수에 2-3 개씩 뭉쳐있다. 이 때 이 뭉치들을 따로 클래스 추출하기하여 하나의 객체로 묶는다.

서로 비슷한 데이터를 한 클래스로 뭉치는 것은 좋은 향기가 나는 코드를 작성하는 지름길이다.

*기본형 집착
기본형을 객체로 바꾸기를 적용하면 기본형만이 있는 구식 형식에서, 의미 있는 자료형들이 있는 최신 형식으로 탈바꿈 할 수 있게 된다.
만약 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면, 타입 코드를 서브클래스로 바꾸기와 조건부 로직을 다형성으로 바꾸기를 적용한다.

자주 함께하는 기본형 그룹도 데이터 뭉치이다. 따라서 클래스 추출하기와 매개변수 객체 만들기를 이용하여 최신형태로 바꿔주어야 한다.

*switch 문의 반복
반복되는 switch 문은 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch 문까지 수정해야 하기 때문이다.
이럴 때 다형성을 잃은 switch 문은 악취를 풍기게 된다.

*반복문
일급 함수(js 에서 함수는 일급함수)의 등장으로 반복문을 파이프라인으로 바꿀 수 있게 되었다. 이는 코드에서 각 원소들이 어떻게 처리되는지 쉽게 확인할 수 있다.

*성의 없는 요소
구조가 필요 없어지는 경우가 생길 수도 있는데, 이 때 함수 인라인하기 나 클래스 인라인하기를 사용하고, 상속을 이용했다면 계층 합치기를 적용할 수 있다.

*추측성 일반화
추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있는데, 이 코드는 테스트 케이스에서부터 삭제한 후 죽은 코드 제거하기로 날려버리자.

*임시 필드
객체를 가져올 때 당연히 모든 필드에 값이 들어있을 것이라고 착각하기 쉽다. 그러므로 임시 필드를 갖도록 작성하는 것은 코드를 이해하기 어렵게 만든다.

*메시지 체인
다른 객체가 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

*중재자
캡슐화를 한 경우 접근이 힘들기 때문에 중개자를 통해서 접근하는 경우가 태반이다. 이 경우 지나치게 된다면 문제가 생기게 되는데 이 때 중개자 제거를 이용한다.

*내부자 거래

*거대한 클래스
클래스가 비대해지는 경우 클래스 추출하기를 통해 나누고, 같은 컴포넌트 끼리는 모아두는 것이 좋다.

*서로 다른 인터페이스의 대안 클래스들
클래스의 가장 큰 장점은 필요에 따라서 다른 클래스로 교체할 수 있다는 점이다.
교체하려면 인터페이스가 같아야 하는데, 따라서 함수 선언 바꾸기를 이용하여 일치 시킨다.
이 방법으로도 부족할 때는 함수 옮기기를 이용하여 인터페이스가 같아질 때 까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
그러다 대안 클래스들이 중복이 심해질 경우 슈퍼클래스 추출하기를 적용할지 고려해 본다.

*데이터 클래스

*상속 포기
상속을 불필요하게 사용하는 경우 같은 계층에 서브클래스를 하나 만들고, 메서드 내리기와 필드 내리기를 이용하여 이용하지 않는 부모 코드를 모조리 서브클래스로 넘기는 것이다.
또한 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 이용하여 상속 메커니즘에서 벗어나는 방법도 있다.

*주석
주석은 물론 필요하지만 알다시피 너무 많은 주석은 오히려 불쾌한 향기만을 남긴다.
주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다.



