-리팩토링 정의

리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 위해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
        ex) 함수 추출하기, 조건부 로직을 다형성으로 바꾸기

리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

코드를 잘게 나눔으로써 처음에는 오래 걸릴 수 있지만, 후에 디버깅을 하는데 있어서 시간을 뺏기지 않을 수 있다.

그리고 리팩터링은 전과 후의 코드 동작이 같아야 한다.

리팩터링은 성능 최적화와 비슷하다. 코드 전반적인 기능은 차이가 거의 없을 정도로 유지함.
리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 수정하는 데에 있다.

성능 최적화는 오로지 속도 개선에만 신경을 쓰기 때문에 속도 성능을 위해서는 코드 다루기가 더 어려워 질 수도 있다.

-두 개의 모자

소프트웨어를 개발 할 때는 두 가지 목적으로 나뉘어진다. 기능 추가인가 혹은 리팩터링을 위해서 인가 이다.

기능추가를 위해서는 기존 코드를 절대 건드리지 않고 오로지 새 기능을 추가하는 것에만 집중한다.

하지만 리팩터링을 위해서는 기능을 추가하지 않고 오로지 코드 재구성에만 전념한다.

테스트도 예외의 상황(앞 과정에서 놓친 테스트 케이스를 발견하는 경우)을 제외하고 새로 만들지 않는다.

부득이하게 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.


- 리팩터링을하는 이유

1. 리팩터링하면 소프트웨어 설계가 좋아진다.

아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너진다. 즉, 코드를 통해 설계를 알 수 없게 되고 후에 유지보수면에서도
큰 어려움을 겪게 된다. 규칙적인 리팩토링은 코드의 구조를 지탱해준다.

물론 코드량이 준다고 해서 속도에 큰 영향을 미치는 것은 아니다. 하지만 코드량이 줄면 수정하는데에 드는 노력이 줄어 들이는 시간이 줄어든다.

2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

프로그래밍은 마치 컴퓨터와 대화하는 것과 같다. 그래서 내가 작성한 코드와 컴퓨터에서 시키려는 일의 차이를 줄여야 한다.
또한 몇 달이 지나 누군가 내 코드를 수정하는 것을 고려한다면, 내 소스는 컴퓨터만이 사용하는 것이 아니다.
컴파일이 조금 더 걸린다고 해서 큰 문제가 되지는 않지만, 내 코드를 수정하느라 하루이틀, 일주일 이상이 걸리게 된다면 사정이 달라지게 된다.

리팩터링은 코드가 더 잘 읽히게 도와준다. 그러므로 코드의 목적을 잘 드러내기 위해, 다시 말해 내 의도를 잘 표현하기 위해 개선해야 한다.

단적인 예로 내가 작성한 코드를 며칠 뒤에만 봐도 이해되지 않는다. 그러므로 나를 위해서라도 이해하기 쉽게 코드를 작성하는 것이 좋다.

3. 리팩터링하면 버그를 쉽게 찾을 수 있다.

4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.

리팩터링 하는데 시간이 드니 전체 개발 속도에 영향이 미칠 수 있다는 생각이 들 수 있다. 물론 초기에는 많은 시간이 걸릴 수 있겠지만,
리팩터링이 잘 된 코드는 기존에 작성한 코드를 최대한 활용할 수 있기 때문에 더 빨리 기능을 추가할 수 있게 된다.

시간 차이의 원인은 소프트웨어의 내부 품질 차이이다. 모듈화가 잘 되어있다면 전체 코드베이스 중 일부만을 수정하면 되기 때문에 어디에 추가할지 고칠지를 알 수 있다.

빠른 개발을 위해서는 이처럼 리팩터링이 반드시 필요하다.


- 언제 리팩터링해야 할까?

3의 법칙
1. 처음에는 그냥한다
2. 비슷한 일을 두 번째로 하게 되면(중복이 생김), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게되면 리팩터링 해야한다.

*준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
함수 매개변수화하기를 적용하여 함수에 필요한 매개변수를 지정해서 호출하기만 하면 됨.
버그를 잡을 때에도 우선 한 곳에 합친 후 작업이 꼬이는 경우를 줄일 수 있다.

*이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
코드를 수정하려면 일단 그 코드가 하는 일을 파악하여야 하는데 내가 파악할 수도, 타인이 파악할 수도 있다.
리팩터링을 하면 머리로 이해한 것을 코드에 옮길 수 있고, 수정한 코드를 테스트하며 확인할 수 있다.

이런 리팩토링은 당장 효과를 볼 때도 많다.

*쓰레기 줍기 리팩터링
코드를 리뷰하며 로직이 쓸데 없이 복잡하거나, 거의 똑같은 함수를 여러개로 작성한 경우를 발견할 수 있다.
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 주석 또는 메모를 남기고 하던 일을 마친 후에 수정하는 것도 좋은 방법이다.
코드를 조금 씩 수정하다보면 결국 문제가 해결되는 경우도 있을 것이다.

*계획된 리팩터링과 수시로 하는 리팩터링
리팩터링은 눈 앞의 문제에도 유용하지만 장기적인 작업에도 도움을 준다.
'보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.'

그러므로 리팩터링 작업은 대부분 드러나지 않게 기회가 될 때마다 해야한다.

*오래걸리는 리팩터링
리팩터링은 대부분 몇 분 안에 끝나지만, 오래 걸리는 경우도 있다. 이럴 때는 한 번에 해결하려고 하는 것보다는 몇 주에 걸쳐 조금씩
해결해가는 편이 효과적일 때가 많다.
기존 코드가 추상 인터페이스를 호출하돋록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다(추상화로 갈아타기)

*코드 리뷰에 리팩터링 활용하기
내 눈에는 명확히 보이는 코드도 다른 이의 눈에는 그렇지 않을 수도 있다. 그러므로 코드 리뷰를 할 수 있다면 개발팀 전체에 코드를 공유하여 피드백을 받는 것이 좋다.
리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 된다. 다른 이의 코드를 리뷰하면서 개선안들을 제시하고, 그 중 상당수를 즉시 구현하여
성취감을 맛볼 수도 있다.

*관리자에게는 뭐라고 말해야 할까?
기술을 모르는 상당수에 관리자는 리팩터링을 하지 말라고 한다. 리팩터링의 영향을 잘 모르기 때문이다. 그럴 때는 '리팩터링한다고 말하지 말라' 를 권한다.
물론 일정을 최우선으로 하는 관리자는 빨리 개발이 끝나길 원하지만 개발자들의 임무는 새로운 기능을 빠르고, 재사용하기 쉽게 구현하는 것이다.
그래서 리팩터링은 해야한다.

*리팩터링하지 말아야 할 때
지금까지는 리팩토링을 무조건 권장하는 것처럼 들렸는데, API 를 호출하는 등 굳이 수정할 필요가 없는 코드라면 지저분해도 수정하지 않는다.
리팩터링하는 것보다 처음부터 작성하는 게 쉬울 때도 리팩터링 하지 않는다.

-리팩터링 시 고려할 문제

*새 기능 개발 속도 저하
리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것 이다.

즉 리팩터링에 있어서는 상황에 맞게 조율하는 것이 필요하다.

코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.

*코드 수요권
한 함수나 코드에 대해서는 한 사람이 관리하는 것이 리팩터링 면에서도 좋고, 소유권을 나눈다면 인터페이스를 수정하는 경우 모두가 확인하거나 꼬이는 경우가
생길 수 있어서 조심해야 한다.

팀 코드에 브랜치를 따서 수정하고 커밋을 요청하는 방식을 지양한다. 코드 소유권을 엄격하게 제한하는 방식과 완전히 푸는 방법의 절충안이라고 할 수 있다.

*브랜치
각 개발자가 독자적인 브랜치에 개발하고 마스터 브랜치에 한 번에 통합하는 방법이 버전을 명확히 나눌 수 있고, 기능에 문제가 생기는 경우 이전 상태로 쉽게
돌릴 수 있어서 좋다고 한다.

하지만 독자적인 개발 시간이 길어질 수록 작업 결과를 통합하기 어려워진다. 그래서 마스터를 개인브랜치로 수시로 리베이스하거나 머지한다.

CI(지속적통합)는 머지의 복잡도를 낮출 수는 있지만, 마스터를 건강하게 유지하기 위해 노력해야하고, 거대한 기능을 잘게 쪼개며, 각 기능을 끌 수 있는 기능 토글을
적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

*테스팅
리팩터링에서 핵심은 오류를 재빨리 잡는데에 있다. 실제로 이렇게 하기 위해서는 코드의 다양한 측면을 검사하는 테스트 스위트가 필요하다.

자가 테스트 코드는 효과가 상당한데, 새 기능 추가도 훨씬 안정하게 진행할 수 있게 도와준다.
실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다.

또한 리팩터링 과정에서 버그가 생길 위험이 크다는 불안감도 해소할 수 있다.

-리팩터링, 아키텍처, 애그니

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.
우리는 요구사항 파악을 잘하지 못한다. 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.

한 가지 방법은 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다.

함수를 범용적으로 사용할 수도 있다는 생각이 들 때가 있는데, 그 시나이로에 대응하기 위해서 매개변수들을 추가한다.
이런 매개변수가 유연성 메커니즘이다.

물론 유용한 수단이지만 계속 사용하다보면 당장의 쓰임에 비해 함수가 너무 복잡해진다.
또한 깜박 잊은 경우, 추가된 매개변수로 인해서 다시 추가하기가 어려워지는 경우가 있다. 이러한 연유로 유연성 매커니즘을 잘못 구현할 때도 있다.

이러한 문제를 리팩토링을 이용해서 해결할 수 있다.
앞으로 어느 부분에 유연하게 대처할 것이고 변화에 대응할 것인지를 추측하고 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.
그리고 이 요구를 만족하기 위한 설계를 한다.

리팩토링을 진행하면서 사용자의 요구사항을 더 잘이해하게 되면 아키텍처도 그에 맞게 리팩터링하여 바꾼다.
이 때 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.
매개변수를 추가할 시점이 오면 간단한 리팩터링 기법인 함수 매개변수화하기로 해결한다.

이런식의 설계 방식을 간결한 설계, 점진적 설계, YAGNI(you aren't going to need it)이라고 불린다.
이 때 아키텍처를 전혀 고려하지 말라는 뜻은 아니다. YAGNI 또한 리팩토링의 뒷받침 없이는 효과를 볼 수 없다.


-리팩터링과 소프트웨어 개발 프로세스

XP 가 도입되면서 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶기 시작했다.
이것을 TDD (테스트 주도 개발) 이라고 한다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다. 프로그래밍 중 일어나는 오류를 확실하게 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.

따라서 YAGNI는 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법으로 강력한 상승효과를 만들어 낼 수 있다.


아무것도 안 만드는 데도 시간이 걸린다. _론 제프리
시스템에 대해서 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다.
그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

리팩터링은 성능 좋은 소프트웨어를 만드는데 기여한다.
단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에
결국 더 빠른 소프트웨어를 얻게 된다.

